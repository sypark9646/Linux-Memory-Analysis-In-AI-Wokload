# -*- coding: utf-8 -*-
"""LRU_simulation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FKQIevw4094wCv1kxtDdK6SXBuAtp6sE
"""

from collections import OrderedDict
 
class LRUCache: # Both reads & writes affect rank changes
    def __init__(self):
        self.cache = OrderedDict()
        # self.capacity = capacity # initialising capacity

    def read(self, key: int) -> int:
        index = 1
        rank = -1
        for i in self.cache.keys(): # return previous rank of key 
          if i == key:
            rank = index
            break
          index += 1
        if key in self.cache:
          self.cache.move_to_end(key, last=False) # move the key to the front when recently used
        return rank
 
    def write(self, key: int) -> int:
        rank = self.read(key)
        if key not in self.cache:
          self.cache[key] = 1
          self.cache.move_to_end(key, last=False)
        return rank

def tocsv(pointer, write_file_name, ranking_access):
  file_write = open(f"{write_file_name}_LRU_{pointer}.txt", "w");
  file_write.write("rank access_number\n")
  for rank in sorted(ranking_access):
    file_write.write(str(rank)+" "+str(ranking_access[rank])+"\n")
  file_write.close()

read_file_name = "raw_data_clear.txt"
write_file_name = read_file_name[:-4]

ranking_access = {}
cache = LRUCache()

pointer = 0
STEP = 100000
with open(read_file_name) as f:
  for line in f:
    data_type, address, size = line.split()
    block_address = int(str(address), 16)
    rank = -1
    if data_type.startswith('read'):
      rank = cache.read(block_address)
    elif data_type.startswith('write'):
      rank = cache.write(block_address)

    if rank != -1:
      ranking_access.setdefault(rank, 0)
      ranking_access[rank] = ranking_access[rank] + 1
    
    pointer += 1
    if pointer % STEP == 0:
      tocsv(pointer, write_file_name, ranking_access)

